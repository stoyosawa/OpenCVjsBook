## 第2章 HTML5のユーザインタフェース

入出力と同じ理由で、OpenCV.jsにはユーザインタフェース機能は用意されていません。ボタンやプルダウンメニューなどにはHTML要素を用います。マウスやキーボードの操作ではイベントリスナーです。

本章では、これらHTMLユーザインタフェース機能のなかでも画像処理で利用する機会の多い`<input>`（タイプは`file`、`button`、`range`）と`<select>`を取り上げます。

CSSは画像上に日本語を重畳表示するときに用います。OpenCV.jsにもテキストを描き込む機能はありますが、フォントの都合で日本語には対応できないからです。


### 2.1 ローカルファイルを選択する

#### 目的

ファイル選択ダイアログボックスから指定したローカル画像ファイルを、無処理のままキャンバスに貼り付けます。

技術的には、[1.2節](./01-html5.md#12-画像をキャンバスに表示する "INTERNAL")の画像表示コードに`<input type="file">`を加えるだけです。ただ、画像読み込み完了通知の`load`イベントとファイル決定の`change`イベントの上がってくるタイミングが微妙に異なるので、それを考慮したコーディングが必要です。あわせて、`HTMLInputElement`から得られるファイルオブジェクト（`File`）の構造とその利用方法も示します。

実行例を次の画面に示します。

<img src="Images/Ch02/ui-file-1.png">

［ファイルを選択］からローカルファイルを指定すれば、`<img>`にその画像が表示されます。画像の横幅は初期状態の枠線が示す320×240に合わせられますが、高さは入力画像のアスペクト比に合わせて調節されます。

ファイル選択後の画面を次に示します。横幅は同じですが、高さがアスペクト比に合わせて小さくなっていることがわかります（元画像が1280×592なので320×148です）。

<img src="Images/Ch02/ui-file-2.png">

#### コード

コード`ui-file.html`を次に示します。

```html
[File] ui-file.html
  1  <!DOCTYPE html>
  2  <html lang="ja-JP">
  3  <head>
  4    <meta charset="UTF-8"></head>
  5    <link rel=stylesheet type="text/css" href="style.css">
  6  <body>
  7
  8  <h1>ローカルファイルを選択する &lt;input type="file"&gt;</h1>
  9
 10  <div>
 11    <img id="imageTag" width="320" height="240" class="placeholder"/>
 12  </div>
 13  <div>
 14    <input type="file" id="fileTag"/>
 15  </div>
 16
 17  <script>
 18    let imgElem = document.getElementById('imageTag');
 19    let fileElem = document.getElementById('fileTag');
 20
 21    function loadImage() {
 22      console.log(performance.now());
 23      let file = fileElem.files[0];
 24      console.log(`${file.name} Size: ${file.size}, Type: ${file.type}`);
 25      imgElem.src = URL.createObjectURL(file);
 26      console.log(performance.now());
 27    }
 28
 29    function changeSize() {
 30      console.log(performance.now());
 31      let aspect = imgElem.naturalHeight / imgElem.naturalWidth;
 32      imgElem.height = Math.floor(imgElem.width * aspect);
 33    }
 34
 35    fileElem.addEventListener('change', loadImage);
 36    imgElem.addEventListener('load', changeSize);
 37  </script>
 38
 39  </body>
 40  </html>
```

#### HTML要素とイベント

ローカルファイル選択のHTML要素は`<input type="file">`です（14行目）。

```html
 14    <input type="file" id="fileTag"/>
```

ファイルが選択されると`change`イベントが上がってくるので、それを契機に`<img>`に画像を読み込みます。イベントリスナーを登録しているのが35行目で、その処理関数が21～27行目の`loadImage()`です。

```javascript
 19    let fileElem = document.getElementById('fileTag');
 ︙
 35    fileElem.addEventListener('change', loadImage);
```

画像が読み込まれると、今度は`<img>`に`load`イベントが発生します。これを契機に`width`、`height`プロパティを変更することで、枠線に画像が収まるようにします。表示上のサイズ値を変更するだけで見かけの大きさを変えられることは、[1.2節](./01-html5.md#12-画像をキャンバスに表示する "INTERNAL")で説明した通りです。プロパティ変更処理は29～33行目の`changeSize()`関数です。


```javascript
 18    let imgElem = document.getElementById('imageTag');
 ︙
 35    imgElem.addEventListener('load', changeSize);
```

#### イベントの時間差

処理関数を読み込みとサイズ変更の2つに分けているのは、それぞれのタイミングが微妙に異なるからです。

選択した画像の読み込みには（後述の25行目）、どんなに早くてもタイムラグがあります。しかし、JavaScriptは画像をすべて読み込むのを待たずに（非同期的に）次の処理に進みます。そのため、読み込み指示の25行目の直下にサイズ変更を入れると、その処理は失敗することもあります。その時点でまだ画像が読み込めていなければ、画像のサイズがわからず、アスペクト比（31行目）が計算できないからです。

その結果、高さが0になり、画像は存在はしますが不可視になります（本コードでは枠線だけは見えます）。高さ0は不正ではない設定なので、これはエラーではありません。しかし、タイミング次第で画像が出たり消えたりするエラーでもない現象には、やはり戸惑うことでしょう。

このタイミングがわかるように、スクリプト開始からの時間を`performacen.now()`からコンソールに表示しています（22、26、30行目）。出力を次に示します（単位はミリ秒）。

```
5918.5                                      // changeイベント発生
cable-car.jpg Size: 188681, Type: image/jpeg
5919.300000011921                           // 読み込み「指示」完了。上から0.8ミリ秒後
5922.900000035763                           // loadイベント発生。上から3.6ミリ秒後
```

ミリ秒単位の微妙な差ですが、差は差です。25行目の読み込みの読み込み指示が終わって、読み込み完了まで3.6ミリ秒の間があります。その間、画像サイズ情報はわからないので、そのタイミングでのサイズ変更は失敗します。

この時間差は場合によって異なります。コンピュータがディスクI/Oで忙しければ、間隔はもっと開くでしょう。

#### ファイルから読み込み

`<input>`で`change`イベントが発生したら、21～27行目の`loadImage()`関数で画像を読み取ります。

```javascript
 21    function loadImage() {
 22      console.log(performance.now());  
 23      let file = fileElem.files[0];
 24      console.log(`${file.name} Size: ${file.size}, Type: ${file.type}`);
 25      imgElem.src = URL.createObjectURL(file);
 26      console.log(performance.now());
 27    }
```

<!-- Chrome なら「Not allowed to load local resource: file:///C:/fakepath/bodega-bay.jpg」というが、Firefoxはなにも言わない。-->
`HTMLInputElement`の`value`プロパティ値は、そのまま`imgElem.src = fileElem.value`のように直接代入はできません。この値には、セキュリティ上の理由で偽のパスが埋め込まれているからです。たとえば、次のようなパスです。

```
C:\fakepath\cable-car.jpg
```

ファイルは`HTMLInputElement`の`files`プロパティに収容されています（23行目）。ただ、そこから`src`に代入できる文字列を得るのは、いくつかのオブジェクトを経由しているのでやや煩雑です。オブジェクトの関連を次の図に模式的に示します。

<!-- 853x275 -->
<img src="Images/Ch02/ui-file-objects.png" width="500">

`HTMLInputElement.files`プロパティの値はリストです。<kbd>Ctrl</kbd>キーを押下しながら、複数のファイルを選択できるように設定できるからです。複数選択は`<input>`に`mulitple`属性を加えることで指定しますが、デフォルトでは1つしか選択できません。ここでもデフォルトで使っています。

ファイルのリストは`FileList`オブジェクトで表現されています。配列同様に利用できるので、最初のファイルを取得するのなら`[0]`でアクセスできます（23行目）。

#### Fileオブジェクト

`FileList`の要素は`File`オブジェクトで、そのファイル名、MIMEタイプ、そしてその中身を収容しています。24行目では、これら情報をコンソールに出力しています。次にコンソール出力を示します。

```
cable-car.jpg Size: 188681, Type: image/jpeg
```

ファイルのデータサイズが188681バイトで、中身が画像であることがわかります。このデータは`Blob`と呼ばれるデータ収納庫で、バッファのようなものです。この段階では単なる「データ」であり、画像のピクセルとして解釈されているわけではないので、サイズ等画像のメタデータを知ることはできません。

`File`オブジェクのままでは`src`は受け付けてくれません。そこで、`URL.createObjectURL()`関数を介してURLとして（内部的に）参照できるものに変換します（25行目）。これなら`HTMLImageElemenet.src`に代入でき、画像が表示されます。読み込まれれば`load`イベントが発生するので、`changeSize()`関数（29～33行目）から表示領域のサイズを変更します。

#### Fileオブジェクトのデータ

蛇足ですが、`File`には`ArrayBuffer`（の`Promise`）を返す`File.arrayBuffer()`関数があります。使えば、`<input type="file">`でファイル選択した段階で画像の生データを確認できます。

生データです。画像の場合は圧縮されたままのバイナリデータなので、ピクセル値は読み取れません。

一部だけチェックするなら`ArrayBuffer.slice()`を使います。その結果を`Uint8Array`を経由して符号なし8ビット整数として配列に変換すれば、コンソールに読める形で出力できます。10進数より16進数がよければ、`map()`で`number.toString(16)`を呼び出して16進数文字列に変換します。

23行目の下に以下を加えれば試せます（先頭13バイトを表示）。

```javascript
    let promise = file.arrayBuffer();
    promise.then(function(ab) {
      console.log(ab.byteLength, [...new Uint8Array(ab.slice(0, 13))]
        .map(b => b.toString(16)));
    });
```

出力結果を次に示します。

```
['ff', 'd8', 'ff', 'e0', '0', '10', '4a', '46', '49', '46', '0', '1', '1']
```

先頭の`FFD8`はJPEG先頭のスタートマーカ、その次の`FFE0`はJFIFブロックの先頭を示します。最後の`0101`はJFIFのバージョン（1.01）を示します。

画像の圧縮形式を直接操作したいときに便利です（たとえばJPEGの量子化テーブルを確認したいなど）。



### 2.2 ビデオをキャプチャする

#### 目的

ビデオフレームを好みのタイミングでキャプチャし、キャンバスに貼り付けます。フレームにはその時点のフレーム番号と時間を描き込みます。

技術的には[1.4節](./01-html5.md#14-ビデオを表示する "INTERNAL")のビデオ表示と変わりません。加わったのはキャプチャ指示の`<input type="button">`ボタン要素とそれをクリックしたときに上がる`click`イベントの処理です。ビデオ時間は[1.5節](./01-html5.md#15-ビデオをランダムにシャッフルする "INTERNAL")で使った`cuurentTime`から取得できます。フレーム番号は、ビデオから得られる`VideoPlaybackQuality`に埋め込まれているので、そのオブジェクトについても説明を加えます。

実行例を次の画面に示します。 

<img src="Images/Ch02/ui-button-1.png">

#### コード

コード`ui-button.html`を次に示します。

```html
[File] ui-button.html
  1  <!DOCTYPE html>
  2  <html lang="ja-JP">
  3  <head>
  4    <meta charset="UTF-8">
  5    <link rel=stylesheet type="text/css" href="style.css">
  6  </head>
  7  <body>
  8
  9  <h1>ビデオをキャプチャする &lt;input type="button"&gt;</h1>
 10
 11  <div>
 12    <video id="videoTag" width="320" autoplay muted
 13      src="samples/ny.mp4"></video>
 14    <canvas id="canvasTag" class="placeholder"></canvas>
 15  </div>
 16  <div>
 17    <input type="button" id="buttonTag" value="WAIT" class="click"/>
 18  </div>
 19
 20  <script>
 21    let videoElem = document.getElementById('videoTag');
 22    let canvasElem = document.getElementById('canvasTag');
 23    let buttonElem = document.getElementById('buttonTag');
 24    let ctx = canvasElem.getContext('2d');
 25
 26    function showImage() {
 27      ctx.drawImage(videoElem, 0, 0, canvasElem.width, canvasElem.height);
 28
 29      let quality = videoElem.getVideoPlaybackQuality();
 30      let frameNumber = quality.totalVideoFrames;
 31      let currentTime = videoElem.currentTime;
 32      ctx.font = '16px sans-serif';
 33      ctx.fillStyle = 'red';
 34      ctx.fillText(`Snapped at ${frameNumber} ${currentTime}`, 10, 30);
 35    }
 36
 37    function imageLoaded() {
 38      canvasElem.width = videoElem.offsetWidth;
 39      canvasElem.height = videoElem.offsetHeight;
 40      buttonElem.addEventListener('click', showImage);
 41      buttonElem.value = 'Snap!';
 42      showImage();
 43    }
 44
 45    videoElem.addEventListener('loadeddata', imageLoaded);
 46  </script>
 47
 48  </body>
 49  </html>
```

文字の描画は、キャンバスの描画コンテクストから行っています（27、32～34行目）。フォントを`font`、文字色を`fillStyle`のプロパティからそれぞれ指定すれば、あとは`fillText()`関数で文字列を描き込むだけです。第2、第3引数で指定する(x, y)座標は文字の左下（正確にはベースライン位置）なので、高さ方向は文字が入るぶん、やや下に位置させます。

#### HTML要素とイベント

ボタン生成のHTML要素は`<input type="button">`です（17行目）。ボタンが押下されれば`click`イベントが発生するので、そのタイミングでフレームをコピーするリスナー関数`showImage()`を登録します（40行目）。


```html
 17    <input type="button" id="buttonTag" value="WAIT" class="click"/>
 ︙
 23    let buttonElem = document.getElementById('buttonTag'); 
 ︙
 40      buttonElem.addEventListener('click', showImage); 
```

ボタンクリックがビデオ読み込み完了のタイミング、つまり`HTMLVideoElement`に上がってくる`loadeddata`に結び付けられた`imageLoaded()`関数内で登録されているのは、[2.1節](#21-ローカルファイルを選択する "INTERNAL")で説明したタイミング上の都合です。もっとも、そこまで厳密に考える必要はありません。最初のフレーム読み込みはミリ秒単位で完了するので、その間隙をついてボタンをクリックできるのは暗殺拳の伝承者くらいです。

#### キャンバスのサイズ

`imageLoaded()`関数はイベントリスナーの登録とともに、キャンバスサイズを設定し（26～27行目）、ボタンの文字列を変更します（29行目）。

```javascript
 22    let canvasElem = document.getElementById('canvasTag');
 ︙
 37    function imageLoaded() {
 38      canvasElem.width = videoElem.offsetWidth;
 39      canvasElem.height = videoElem.offsetHeight;
 40      buttonElem.addEventListener('click', showImage);
 41      buttonElem.value = 'Snap!';
 42      showImage();
 43    }
 ︙
 45    videoElem.addEventListener('loadeddata', showImage);
```

キャンバスサイズの設定では、`HTMLVideoElement.offsetWidth`と`offsetHeight`の値を用いているところがポイントです。`HTMLVideoElement.height`は`<video height=>`でセットしていないので、`undefined`だからです（[1.4節](./01-html5.md#14-ビデオを表示する "INTERNAL")参照）。不用意に使うと、次の画面に示すように高さ0のキャンバスになります。

<img src="Images/Ch02/ui-button-2.png">

ここではCSSを使って枠線を描いているのでキャンバスがあることが確認できますが、なければ、なにを貼り付けても見ることができません。

末尾で`showImage()`を呼び出しているのは、ユーザがボタンクリックする前でも、最初のフレームをキャンバスに表示するためです。ビデオは`autoplay`を指定しているので自動的にスタートします（12行目）。自動スタートがなければ、まだフレームデータは用意できないので、キャンバスは空のままです。

#### 品質メトリックス

`HTMLVideoElement`には現在時刻を示す`currentTime`プロパティはありますが（31行目）、現在のフレーム番号を収容したプロパティはありません。もっといえば、総フレーム数などフレームに関わるプロパティは一切ありません。

フレーム数が必要なら、品質メトリックスを管理する`VideoPlaybackQuality`オブジェクトから取得します。このオブジェクトは`HTMLVideoElement.getVideoPlaybackQuality()`から得られます（29行目）。そして、フレーム番号はその`totalVideoFrames`プロパティから取得できます（30行目）。

```javascript
 29      let quality = videoElem.getVideoPlaybackQuality();
 30      let frameNumber = quality.totalVideoFrames;
 31      let currentTime = videoElem.currentTime;
```

このプロパティは「これまでに得られたフレームの数」を収容しています。再生性能の都合などでフレーム落ちがあればそのぶんは含まれないので、厳密には「フレーム番号」ではありません。また、リピート再生をしていれば累積した数が報告されますし、スライダで途中を飛ばせばそのぶんはなかったことになります。

つまり、参考程度です。特定のフレーム番号に飛ばしたいなど、フレームに依拠したスクリプティングには精度不足です。この機能をサポートしてないブラウザもあります。`currentTime`プロパティのほうがより正確なので、フレーム位置を特定したいときはそちらを用います。



### 2.3 カメラにオンオフボタンを加える（ポスター付き）

#### 目的

カメラにトグル式のオンオフボタンを加えます。映像の停止中には、あらかじめ用意した画像を表示します。

技術的には、[1.8節](./01-html5.md#18-カメラ映像を流す "INTERNAL")のコードで使った`<input type="button">`でボタンに、停止時は「起動」、撮像中は「停止」と表示文字をトグルするためにの状態管理を導入します。

停止中の画像はポスターフレームと呼ばれ、通常の用法では`<video>`の`poster`属性にURLを設定します。ここでは、URLから画像ファイルを読み込むのではなく、描画コンテクスト機能でその場で作成します。スクリプトから生成した画像データをURLを要求するプロパティに挿入するには、URL風に変換する必要があります。本節では、この操作を担当する`toDataURL()`関数も説明します。ポスター画像生成機能は関数化することで、他所からも利用できるようにします。

実行例を次の画面に示します。先に、ポスター画像が示される停止状態です。ボタンが「起動」を示しています。

<img src="Images/Ch02/ui-soundonly-1.png">

ボタンをクリックすれば再生状態です。ボタンが「停止」に変わります。

<img src="Images/Ch02/ui-soundonly-2.png">

#### コード（関数）

ポスター画像を生成する部分は、関数化して別ファイル`libs/seele.js`に収容しました。次に示します。

```javascript
[File] libs/seele.js
  7  function soundOnly(w=320, h=240, fontSize=48) {
  8    let canvasElem = document.createElement('canvas');
  9    canvasElem.width = w;
 10    canvasElem.height = h;
 11    let ctx = canvasElem.getContext('2d');
 12
 13    let text = 'SOUND ONLY';
 14    let color = 'rgb(252, 0, 0)';
 15
 16    ctx.fillStyle = 'black';
 17    ctx.fillRect(0, 0, w, h);
 18
 19    ctx.font = `bold ${fontSize}px "Helvetica"`;
 20    ctx.letterSpacing = `-${fontSize/16}px`;
 21    ctx.textBaseline = 'middle';
 22    ctx.textAlign = 'center';
 23    ctx.lineWidth = 3.0;
 24    ctx.strokeStyle = color;
 25    ctx.shadowColor = color;
 26    ctx.shadowBlur = 11;
 27    ctx.strokeText(text, w/2, h/2, maxWidth=w);
 28
 29    return canvasElem.toDataURL();
 30  }
```

#### ポスター画像生成関数

描き込むフォントの設定が多いので長いですが、根幹は`strokeText()`（27行目）で文字を描くだけの単純な作りです。

ポスター画像生関数の`soundOnly()`は引数に画像の横幅（`w`）、高さ（`h`）、フォントの大きさ（`fontSize`）を指定できます。横幅に入りきらないような大きなフォントサイズを指定すると、無理に収めるために文字が縦長になります（27行目の`strokeText()`の第4引数`maxWidth`が横幅に指定してある）。

戻り値はデータURLです。これは、画像のバイナリデータで、URL文字列を受け付ける`HTMLVideoElement.poster`に直接代入できます（後述）。

スクリプトでHTML要素を自動生成するには`document.createElement()`関数を使います（8行目）。

```javascript
  8    let canvasElem = document.createElement('canvas');
```

作成したDOMオブジェクトは`appendChild()`関数で親要素の下に配置するのが通例ですが、ここではそれをしていません。データURLを生成することだけが目標で、要素としてドキュメントページに張り付ける必要がないからです。

描画でのポイントは文字色を少しだけ暗めな赤にするところ（13行目）、フォントはヘルベチカの太字にするところ（18行目）、文字の間隔を詰め気味にするところ（19行目）、そして、全体がぼーっと光るようにぼかしを入れているところです（26行目）。文字列を画像中央に配置できるよう、文字列のベースラインと横位置をどちらも真ん中にしているところもポイントです（21～22行目）。

本物は2語が2段に分けられているとか、フォントは実はマティスだとか、背景のぼかし赤がもっと広いとか、及ばぬところは多々あります。本物は次のURLから得られる公式の「エヴァンゲリオン壁紙」から取得できます。

```https://www.evangelion.co.jp/news/web_screen/```

#### データURL

キャンバス上に描いた画像は、`HTMLCanvasElement.toDataURL()`関数からデータURLに変換します（29行目）。

```javascript
 29    return canvasElem.toDataURL();
```

データURLはデータそのものを含んだURLです。アイコンなど小さなデータを別ファイルからダウンロードするのではなく、HTMLに直接埋め込むときに用いられます。URLですから文字列です。文字列なので、そのままコンソールに表示できます。次に、SoundOnly画像の先頭の64バイトを示します。

```
data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAeAAAAFoCAYAAACPNy
```

URLらしく、先頭が「data:」となっています。これにMIMEタイプが続きます（ここでは`image/png`）。セミコロン以降がデータで、先付けされているbase64,はデータがBase64でエンコーディングされていることを示しています。

Base64はバイナリデータをASCII文字だけで表現する方法です。JavaScriptではバイナリデータをBase64に変換する`btoa()`、その反対のBase64をバイナリに戻す`atob()`関数が用意されています。

次の例は、コンソールで0から9の値を持つ符号なし8ビット整数の配列（`Uint8Array`）をBase64に変換しています（`>`が入力、`<`が出力。一部省略）。

```
> bin = new Uint8Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);
< Uint8Array(10) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, buffer: ArrayBuffer(10), ....
> btoa(bin)
< 'MCwxLDIsMyw0LDUsNiw3LDgsOQ=='
```

Base64はインターネット標準のRGC 4648で定義されています。ネットワーク関連でよく見かける技術なので、興味のある方は次のURLを参照してください。

```https://www.rfc-editor.org/info/rfc4648```

#### コード（メイン部分）

メイン部分のコード`ui-soundonly.html`を次に示します。

```html
[File] ui-soundonly.html
[File] ui-soundonly.html
  1  <!DOCTYPE html>
  2  <html lang="ja-JP">
  3  <head>
  4    <meta charset="UTF-8">
  5    <link rel=stylesheet type="text/css" href="style.css">
  6    <script src="libs/seele.js"></script>
  7  </head>
  8  <body>
  9
 10  <h1>カメラにオンオフボタンを加える（ポスター付）</h1>
 11
 12  <div>
 13    <video id="videoTag" muted></video>
 14  </div>
 15  <div>
 16    <input type="button" id="buttonTag" value="起動" class="click"/>
 17  </div>
 18
 19  <script>
 20    let cameraSettings = {
 21      audio: false,
 22      video: {
 23        width: 320,
 24        height: 240,
 25      }
 26    };
 27    let cameraState = 0;
 28    let opString = ['起動', '停止'];
 29
 30    let videoElem = document.getElementById('videoTag');
 31    let buttonElem = document.getElementById('buttonTag');
 32    videoElem.poster = soundOnly(
 33      cameraSettings.video.width, cameraSettings.video.height
 34    );
 35
 36    function cameraStart() {
 37      navigator.mediaDevices.getUserMedia(cameraSettings)
 38      .then(function(mediaStream) {
 39        videoElem.srcObject = mediaStream;
 40        videoElem.play();
 41      });
 42    }
 43
 44    function cameraStop() {
 45      videoElem.pause();
 46      let tracks = videoElem.srcObject.getVideoTracks();
 47      tracks.map(function(track) {
 48        track.stop();
 49      });
 50      videoElem.srcObject = undefined;
 51    }
 52
 53    function startStop() {
 54      [cameraStart, cameraStop][cameraState]();
 55      cameraState = 1 - cameraState;
 56      buttonElem.value = opString[cameraState];
 57    }
 58
 59    buttonElem.addEventListener('click', startStop);
 60  </script>
 61
 62  </body>
 63  </html>
```

こちらも長いですが、ほとんど以前のものを使いまわしています。`<input type="button">`を用いたボタン操作（16、31、59行目）は前節を踏襲しています。カメラ設定（20～26行目）、カメラ開始（36～42行目）、カメラ停止（44～51行目）は[1.8節](./01-html5.md#18-カメラ映像を流す "INTERNAL")とまったく同じです。新しく加わったのは、開始停止をコントロールする`startStop()`関数（53～57行目）くらいです。

`libs/seele.js`から得られたデータURLは、そのまま`HTMLVideoElement.poster`に代入します（32～34行目）。

#### ボタンのトグル操作

カメラのオンオフ状態は27行目の`cameraState`で管理します。

```javascript
 27    let cameraState = 0;
 28    let opString = ['起動', '停止'];
```

0は停止中（初期状態）、1は再生中を意味します。オンオフなら真偽値を使った方がわかりがよいのですが、数値のほうが29行目の文字列配列にアクセスしやすくなります。

オンオフ操作は`startStop()`関数で定義してあります（53～57行目）。

```javascript
 53    function startStop() {
 54      [cameraStart, cameraStop][cameraState]();
 55      cameraState = 1 - cameraState;
 56      buttonElem.value = opString[cameraState];
 57    }
```

開始と停止の関数は52行目で呼びだしています。0なら`cameraStart()`、1なら`cameraStop()`と`if`で切り分けてもよいのですが、状態値を整数にしているので、配列要素から実行できて都合がよいです。また、1から現在値を引くだけで状態遷移もできます（55行目）。



### 2.4 日本語文字を画像に重畳する

#### 目的

日本語文字列を別レイヤーとして画像上に重畳します。文字列はキーボードから隠す、再表示する、テキスト（ただし固定）を変えてランダムな位置に配置するという操作ができるようにします。


技術的には、背景が透明な`<span>`を用意し、それをCSSの`display`プロパティを用いて画像の上に載せるだけです。とりたてて珍しい技法ではありませんが、フォントの都合で日本語文字列を描画できないOpenCVには必須の小技です。この機能はクラス化することで、日本語表示が必要になったときに使いまわせるようにします。  画像はデフォルトではキーボード入力を受け付けないので、`contenteditable`属性を介して操作可能にする方法もあわせて示します。

実行例を次の画面に示します。 

<img src="Images/Ch02/ui-overlay-1.png">

画像の周囲に黒枠が描かれているのは、フォーカス（要素をマウスで選択）したときの`<img>`の挙動で、スクリプトからのものではありません。

#### CSSによる文字要素の重畳

まず、HTML/CSSだけで文字要素をレイヤーとして重畳する方法を示します。例示用のコード`ui-overlay1.html`を次に示します。

```html
[File] ui-overlay1.html
  1  <!DOCTYPE html>
  2  <html lang="ja-JP">
  3  <head>
  4    <meta charset="UTF-8">
  5    <link rel=stylesheet type="text/css" href="style.css">
  6  </head>
  7  <body>
  8
  9  <h1>画像上に文字入りの要素をオーバレイする</h1>
 10
 11  <div style="position: relative;">
 12    <img width="320" src="samples/san-gimignano.jpg"/>
 13    <span style="color: white; position: absolute; top: 0px; left: 0px;">
 14      San Gimignano</span>
 15  </div>
 16
 17  </body>
 18  </html>
```

画像`<img>`（12行目）の上に文字列を収容した`<span>`（13～14行目）を重畳します。

ポイントは`<img>`と`<span>`が`<div>`で囲まれていて（11、15行目）、その`<div>`には`position: relative`が指定されているところです。加えて、`position: absolute`を指定することで、`<div>`内の要素を任意の場所に絶対位置で配置できるようになります。位置は`top`や`left`などのプロパティから指定します。13行目で指定している位置は`<div>`内の座標系で、(0, 0）は`<div>`の左上の角に`<span>`の左上の角を合わせて配置するという意味です。

#### コード（クラス）

文字列を重畳する部分は、クラス化して別ファイル`libs/overley.js`に収容しました。次に示します。

```javascript
[File] libs/overlay.js
  3  class Overlay {
 ︙    
 14    constructor(divOuterTag, text='Hello World', x=0, y=0,
 15      fontSize=48, color='white', bgcolor='transparent') {
 16        this.divOuterElem = document.getElementById(divOuterTag);
 17        this.spanElem = document.createElement('span');
 18
 19        this.divOuterElem.style.position = 'relative';
 20
 21        this.spanElem.style.position = 'absolute';
 22        this.spanElem.style.top = `${y}px`;
 23        this.spanElem.style.left = `${x}px`;
 24        this.spanElem.style.fontFamily = '"メイリオ", "Meiryo"';
 25        this.spanElem.style.fontSize = `${fontSize}px`;
 26        this.spanElem.style.color = color;
 27        this.spanElem.style.backgroundColor = bgcolor;
 28        this.spanElem.innerHTML = text;
 29
 30        this.divOuterElem.appendChild(this.spanElem);
 31      }
 32
 33      show() {
 34        this.spanElem.style.display = 'inline';
 35      }
 36
 37      hide() {
 38        this.spanElem.style.display = 'none';
 39      }
 40
 41      changeText(text, fontSize=-1, x=-1, y=-1) {
 42        this.spanElem.innerHTML = text;
 43        if (fontSize >= 0)
 44          this.spanElem.style.fontSize = `${fontSize}px`;
 45        if (x >= 0)
 46          this.spanElem.style.left = `${x}px`;
 47        if (y >= 0)
 48          this.spanElem.style.top = `${y}px`;
 49      }
 50    }
```

クラスのコンストラクタ―には文字列を設定するいくつかの引数が用意されています。

- `divOuterTag`...ここで生成する`<span>`要素を取り囲む要素の`id`識別子です。先に示した`ui-overlay1.html`でいえば11行目の`<div>`です。この要素の`position: relative;`は19行目で設定しているので、要素記述時点で属性からセットする必要はありません。この引数は必須です。
- `text`...表示する文字列です。デフォルトでHello Worldが用意してありますが、いつもこれのわけはないので、必須同様の引数です。コードでは28行目で用います。
- `x`...外側要素から相対的に見た水平方向位置です。重畳する`<span>`の左端がこの位置に揃えられます。単位はピクセルです。22行目で用います。
- `y`...外側要素から相対的に見た垂直方向位置です。重畳する`<span>`の上端がこの位置に揃えられます。単位はピクセルです。23行目で用います。
- `fontSize`...フォントサイズで、単位はこれもピクセルです。25行目で用います。
- `color`...フォントの色指定です。CSSで用いられる色文字列ならどのような形式でもかまいません。26行目で用います。
- `bgcolor`...`<span>`の背景色でデフォルトは透明です。27行目で用います。

他にもパラメータ化したいプロパティはいろいろあるでしょうが、あまり多すぎると使いにくいのこれくらいにしました。好みに応じて加えてください。

コンストラクタでは`<span>`要素を`createElement()`関数で用意し、`appendChild()`で外側要素を親にして貼り付けています。なので、コンストラクタを呼び出した時点で文字列が可視になります。

3つの関数には次の機能を実装してあります。

- `show()`...文字の表示（33～35行目）。
- `hide()`... 文字の非表示（37～39行目）。
- `changeText()`...描画文字列、位置、フォントサイズの変更（41～49行目）。

いずれもCSS（`style`プロパティ）に対応するプロパティを操作しているだけなので、とくに説明は要しないでしょう。

#### コード（テスト用）

クラスをテストするためのコード`ui-overlay2.html`を次に示します。

```html
[File] ui-overlay2.html
  1  <!DOCTYPE html>
  2  <html lang="ja-JP">
  3  <head>
  4    <meta charset="UTF-8">
  5    <link rel=stylesheet type="text/css" href="style.css">
  6    <script src="libs/overlay.js"></script>
  7  </head>
  8  <body>
  9
 10  <h1>日本語文字の重畳とキーボード処理（スクリプト版）</h1>
 11
 12  <p>画像をフォーカスしてからキー操作。s=show(), h=hide(), c=changeText()</p>
 13
 14  <div id="divTag">
 15    <img id="imageTag" width="320" contenteditable="true"
 16      src="samples/san-gimignano.jpg"/>
 17  </div>
 18
 19  <script>
 20    let imgElem = document.getElementById('imageTag');
 21    let o = new Overlay('divTag', 'San Gimignano');
 22
 23    function test(evt) {
 24      switch(evt.code) {
 25      case 'KeyS':
 26        o.show();
 27        break;
 28      case 'KeyH':
 29        o.hide();
 30        break;
 31      case 'KeyC':
 32        let fontSize = Math.floor(Math.random()*10) + 12;
 33        let x = Math.floor(Math.random() * imgElem.width);
 34        let y = Math.floor(Math.random() * imgElem.height);
 35        console.log(fontSize, x, y);
 36        o.changeText('The City of Fine Towers', fontSize, x, y);
 37        break;
 38      }
 39    }
 40
 41    imgElem.addEventListener('keydown', test);
 42  </script>
 43
 44  </body>
 45  </html>
```

#### キーボード操作

3つの関数をインタラクティブに試せるよう、キー操作から3つの関数を呼び出せるようにしています。

しかし、HTML要素の大半はデフォルトではキー操作が可能ではありません。そこで、明示的に`contenteditable`属性をセットすることで、`<img>`要素でもキー押下を受け付けるようにしています（15行目）。

```html
 15    <img id="imageTag" width="320" contenteditable="true"
 16      src="samples/san-gimignano.jpg"/>
```

キーが押下されときのイベント`keydown`を受け付けるのが`<img>`オブジェクトなのが注意点です（41行目）。

```javascript
 41    imgElem.addEventListener('keydown', test);
```

`test()`関数はs、h、cが押下されたときに、それぞれ`show()`、`hide()`、`changeText()`関数を呼び出しているだけです。

```javascript
 23    function test(evt) {
 24      switch(evt.code) {
 25      case 'KeyS':
 ︙
 28      case 'KeyH':
 ︙
 31      case 'KeyC':
```

上がってきたイベントは、イベントリスナーの引数に引き渡されます。23行目の`evt`オブジェクトがそれで、そこから`code`プロパティが参照できます（24行目）。`keydown`イベントには、押下されたキーの文字を収容した`key`など、キーボード操作に関わるプロパティがいくつかありますが、`code`は<kbd>Shift</kbd>などの修飾キーの組み合わせとは無関係にキーボードの物理コードを返すのが便利です。

キーコードは文字列表記で、アルファベットキーはKey（Kは大文字）に大文字で構成されています。たとえばKey + Sです。これ以外のキーコードは、次のURLから参照できるMDNの「Code values for keyboard events」を参照してください。

```https://developer.mozilla.org/en-US/docs/Web/API/UI_Events/Keyboard_event_code_values```

`changeText()`では配置位置とフォントサイズをランダムに変化させています。位置やサイズによっては`<img>`からはみ出しますが、それでエラーになることはありません。

#### クラスの呼び出し

文字重畳クラスを使うには`<script>`で`overlay.js`を読み込み（6行目）、`new Overlay()`からインスタンス化します（21行目）。HTML側では、重畳先の`<img>`が`id`付きの`<div>`に囲まれているところがポイントです。

```html
  6    <script src="libs/overlay.js"></script>
  ︙
 14  <div id="divTag">
 15    <img id="imageTag" width="320" contenteditable="true"
 16      src="samples/san-gimignano.jpg"/>
 17  </div>
 ︙
 21      let o = new Overlay('divTag', 'San Gimignano');
```

初期状態ではSan Gimignano（サン・ジミニャーノと発音）が表示されますが、C押下で3行目からThe City of Fine Towersに変わります。



### 2.5 プルダウンメニューからフィルタを選択する

#### 目的

プルダウンメニューから選択したフィルタを適用した画像を、キャンバスに表示します。

技術的には、CSSの`filter`プロパティ値を`<select>`要素から変更するだけのシンプルなものなので、説明をするのは`HTMLSelectElement`のプロパティとイベントくらいです。CSSフィルタは現在10種類が定義されていますが、ここではそのうち7つを選択できるようにしています。

実行例を次の画面に示します。平滑化フィルタを選択したときのものです。

<img src="Images/Ch02/ui-options-1.png">

左が元画像を示す`<img>`、右がフィルタ適用後の画像を貼り付けた`<canvas>`です。キャンバス上の文字列は前節の`libs/overlay.js`で重畳しています。

#### コード

コード`ui-options.html`を次に示します。

```html
[File] ui-options.html
  1  <!DOCTYPE html>
  2  <html lang="ja-JP">
  3  <head>
  4    <meta charset="UTF-8"></head>
  5    <link rel=stylesheet type="text/css" href="style.css">
  6    <script src="libs/overlay.js"></script>
  7  <body>
  8
  9  <h1>プルダウンメニューからフィルタを選択する &lt;select&gt;</h1>
 10
 11  <div>
 12    <img id="imageTag" width="320" src="samples/bodega-bay.jpg"/>
 13    <div id="divTag" class="inline">
 14      <canvas id="canvasTag" class="placeholder"></canvas>
 15    </div>
 16  </div>
 17  <div>
 18    <select id="selectTag">
 19      <option value="none">オリジナル</option>
 20      <option value="blur(5px)">平滑化（ぼけ）</option>
 21      <option value="brightness(150%)">明るさ増強</option>
 22      <option value="contrast(150%)">コントラスト増強</option>
 23      <option value="grayscale(90%)">モノクロ化（90%）</option>
 24      <option value="invert(100%)">ネガポジ変換</option>
 25      <option value="saturate(150%)">彩度増強</option>
 26      <option value="sepia(90%)">セピア調</option>
 27    </select>
 28  </div>
 29
 30  <script>
 31    let imgElem = document.getElementById('imageTag');
 32    let canvasElem = document.getElementById('canvasTag');
 33    let ctx = canvasElem.getContext('2d');
 34    let selectElem =  document.getElementById('selectTag');
 35    let overlay = undefined;
 36
 37    function imageLoaded(evt) {
 38      canvasElem.width = imgElem.width;
 39      canvasElem.height = imgElem.height;
 40      ctx.drawImage(imgElem, 0, 0, imgElem.width, imgElem.height);
 41      selectElem.addEventListener('change', filterSelected);
 42      overlay = new Overlay('divTag', 'オリジナル', 0, 0, 24, 'black', 'white');
 43    }
 44
 45    function filterSelected(evt) {
 46      let t = evt.target;
 47      canvasElem.style.filter = t.value;
 48      overlay.changeText(t.options[t.selectedIndex].innerHTML);
 49    }
 50
 51    window.addEventListener('load', imageLoaded);
 52  </script>
 53
 54  </body>
 55  </html>
```

#### HTML要素とイベント

<!-- HTMLOptionElement にはイベントは発生しない模様 -->
プルダウンメニューは、選択肢を示す`<option>`を括った`<select></select>`要素で構成します（18～27行目）。

```html
 18    <select id="selectTag">
 19      <option value="none">オリジナル</option>
 20      <option value="blur(5px)">平滑化（ぼけ）</option>
 21      <option value="brightness(150%)">明るさ増強</option>
 22      <option value="contrast(150%)">コントラスト増強</option>
 23      <option value="grayscale(90%)">モノクロ化（90%）</option>
 24      <option value="invert(100%)">ネガポジ変換</option>
 25      <option value="saturate(150%)">彩度増強</option>
 26      <option value="sepia(90%)">セピア調</option>
 27    </select>
```

プルダウンメニューの選択を実行できるようになるのはすべてのリソース（画像とスクリプト）が読み込まれてからなので、処理関数の`filterSelected()`は`window`に`load`イベントが上がってから登録しています。

```javascript
 37    function imageLoaded(evt) {
 ︙
 41      selectElem.addEventListener('change', filterSelected);
 ︙
 43    }
 ︙
 51    window.addEventListener('load', imageLoaded);
```

> `load`イベントの登録先を`document`にすると、ページのDOMが構築された直後にイベントが発火します。これは画像や外部リソースが読み込まれる前です。`window`はリソースがすべて読み込まれたあとなので、それよりも遅れて発火します。

イベントリスナーに引き渡されるイベントオブジェクト`evt`には`target`プロパティがあり（46行目）、このイベントを上げてきた`<select>`のオブジェクトが格納されています。その`value`プロパティには、選択した`<option>`の`value`値が収容されています（47行目）。たとえば"blur(5px)"（文字列）です。

```javascript
 45    function filterSelected(evt) {
 46      let t = evt.target;
```

あとは、これをキャンバスの`style.filter`プロパティに直接代入するだけでフィルタリングが発動します。CSSスタイルの値は文字列なので、加工の必要すらありません。

```javascript
 47      canvasElem.style.filter = t.value;
```

#### CSS画像フィルタ

CSS画像フィルタは`filter: filtername();`の形で指定できます。`filtername()`は関数で、引数にはフィルタの強度を指定するパラメータを指定します。`<img>`に直接埋め込むなら次のように書きます。これは平滑化（`blur()`）の例です。

```html
<img src="samples/bodega-bay.jpg" style="filter: blur(5px);"/>
```

ここで利用する`filter`関数、用いる値、機能を次の表に示します。

関数名 | 使用する値 | 機能
---|---|---
`none` | -- | フィルタを適用しない（元画像のまま）。
`blur()` | 5px | 画像を平滑化、つまりぼけさせる（[6.2節](./06-img.md#62-画像をぼかす "INTERNAL")）。引数には、ガウシアンフィルタの大きさをピクセル値などから指定する。大きいほどぼけが強くなる。
`brightness()` | 150% | 画像を暗くしたり、明るくしたりする。100%未満だと暗くなり、100%では今のまま、100%より大きければ明るくなる。
`contrast()` | 150% | コントラスト（濃淡の差異の大きさ）調整（[6.7節](/06-img.md#67-顔を検出する "INTERNAL")）。100%未満だとコントラストが低下し、100%では今のまま、100%より大きければコントラストが強くなる。
`grayscale()` | 90% | モノクロ化する（[5.3節](./05-colors.md#53-セピア調にする（およびその他の線形フィルタ） "INTERNAL")）。100%は完全なモノクロで、0%だと変化なしです。0～100%の間だと微妙にカラーが残る。
`invert()` | 100% | 銀塩写真のネガのように画像をネガに変換する（[5.2節](./05-colors.md#52-ネガにする "INTERNAL")）。100%だと完全に反転してネガ状態になり、0～100%の間だと微妙な塩梅で反転する。
`saturate()` | 150% | 彩度調整。0%だと無彩色（モノクロ）になり、100%だと変化なし。それより上げれば彩度が増して極彩色になる。
`sepia()` | 90% | セピア調にする（[5.3節](./05-colors.md#53-セピア調にする（およびその他の線形フィルタ） "INTERNAL")）。0%は変化なし、100%なら完全なセピア化。

大きさの単位にはピクセル数（px）やフォントサイズの値（em）などいろいろなありますが、表ではよく使うものだけに絞って説明しています。本書でその原理を説明しているものには、該当する章節番号が示してあります。

次に示すMDNのページには、`filter`で利用できる関数がリストされています。また、それぞれの関数の詳細説明ページへのリンクがあり、値と結果をサンプルから参照できるようになっています。

```https://developer.mozilla.org/ja/docs/Web/CSS/filter```

本コードでのそれぞれの実行結果を示します。

<table>
  <tr>
    <td><img src="Images/Ch02/ui-options-filter-0.png" width="200"></td>
    <td><img src="Images/Ch02/ui-options-filter-1.png" width="200"></td>
    <td><img src="Images/Ch02/ui-options-filter-2.png" width="200"></td>
    <td><img src="Images/Ch02/ui-options-filter-3.png" width="200"></td>
  </tr>
  <tr>
    <td><img src="Images/Ch02/ui-options-filter-4.png" width="200"></td>
    <td><img src="Images/Ch02/ui-options-filter-5.png" width="200"></td>
    <td><img src="Images/Ch02/ui-options-filter-6.png" width="200"></td>
    <td><img src="Images/Ch02/ui-options-filter-7.png" width="200"></td>
  </tr>
</table>

#### 文字列重畳

画像左上に表示されるキャプションは、前節で作成した`Overlay`クラスで重畳しています（6、42、48行目）。

```html
  6    <script src="libs/overlay.js"></script>
 ︙  
 42      overlay = new Overlay('divTag', 'オリジナル', 0, 0, 24, 'black', 'white');
 ︙
 48      overlay.changeText(t.options[t.selectedIndex].innerHTML);
```

ここでは、重畳する`<span>`の文字は黒、背景は白にしています（42行目）。

`<option></option>`に挟まれた文字列の取得は、48行目に示したようにやや迂路を辿っています。というのも、`evt.target`は`<select>`への参照で、そこには選択された`<option>`オブジェクトそのものは含まれていないからです。

`HTMLSelectElement`には、内側の`<option>`すべてをリストした`options`プロパティがあります。これは配列です。そして、選択された`<option>`の配列位置は、`selectedIndex`に収容されています。選択した`HTMLOptionElement`オブジェクトを抽出するには、したがって`HTMLSelectElement.options[HTMLSelectElement.selectedIndex]`とやります。オブジェクトが得られたら、`innerHTML`プロパティから文字列が取得できます。



### 2.6 トラックバーからサイズを調整する

#### 目的

トラックバーからキャンバスにコピーした画像のサイズを変更します。

トラックバーは、つまみを左右にスライドすることで音量や再生位置を設定するユーザインタフェースです。最小と最大の値が決まっていて、その間ならどの値でも、正確ではなくても直感的に決定できるようにするときに利用するものです。

技術的には、`<input type="range">`、そのプロパティとイベントを説明するだけです。画像のリサイズは[1.3節](./01-html5.md#13-部分領域をキャンバスに表示する "INTERNAL")で説明したように、`drawImage()`の引数を調節するだけです。

実行例を次の画面に示します。

<img src="Images/Ch02/ui-range-1.png">

スライダーの操作につれて、キャンバス上の画像が縮小拡大します。ユーザインタフェースは普段は画像の下に置いていますが、今回は上です。右のキャンバス画像が大きくなるとトラックバーが下へ下へと追いやられて使いにくいからです。

トラックバー横の値は横幅のピクセルサイズで、順に最小値、現在値、最大値です。現在値はスライダーの動きとともに変化します（この時点では370を示しています）。最小値の10は決め打ちですが、最大値は元画像の`naturalWidth`から取ってきています。高さは元画像のアスペクト比から計算しています。

#### コード

コード`ui-range.html`を次に示します。

```html
[File] ui-range.html
  1  <!DOCTYPE html>
  2  <html lang="ja-JP">
  3  <head>
  4    <meta charset="UTF-8"></head>
  5    <link rel=stylesheet type="text/css" href="style.css">
  6  <body>
  7
  8  <h1>トラックバーからサイズを調整する &lt;input type="range"&gt;</h1>
  9
 10  <div>
 11    <input type="range" id="rangeTag"/>
 12    <span id="spanTag" class="currentValue">横幅調節</span>
 13  </div>
 14  <div>
 15    <img id="imageTag" width="320" src="samples/sfo-houses.jpg"/>
 16    <canvas id="canvasTag" class="placeholder"></canvas>
 17  </div>
 18
 19  <script>
 20    let imgElem = document.getElementById('imageTag');
 21    let canvasElem = document.getElementById('canvasTag');
 22    let ctx = canvasElem.getContext('2d');
 23    let rangeElem = document.getElementById('rangeTag');
 24    let spanElem = document.getElementById('spanTag');
 25
 26    function render() {
 27      ctx.drawImage(imgElem, 0, 0, canvasElem.width, canvasElem.height);
 28      spanElem.innerHTML =
 29        `${rangeElem.min}≦${rangeElem.value}≦${rangeElem.max}`;
 30    }
 31
 32    function imageLoaded() {
 33      canvasElem.width = imgElem.width;
 34      canvasElem.height = imgElem.height;
 35      rangeElem.min = 10;
 36      rangeElem.max = imgElem.naturalWidth;
 37      rangeElem.value = imgElem.width;
 38      rangeElem.addEventListener('input', sizeChanged);
 39      render()
 40    }
 41
 42    function sizeChanged(evt) {
 43      let aspect = imgElem.naturalHeight / imgElem.naturalWidth;
 44      canvasElem.width = Number(rangeElem.value);
 45      canvasElem.height = Math.floor(aspect * canvasElem.width);
 46      render();
 47    }
 48
 49    window.addEventListener('load', imageLoaded);
 50  </script>
 51
 52  </body>
 53  </html>
```

キャンバスへの画像の貼り付けと、最小、現在、最大の値を`<span>`要素に書き出す部分は、26～30行目の`render()`関数にまとめています。`CanvasRenderingContext2D.drawImage()`の引数の使い方次第で画像の拡大縮小ができることは[1.3節](./01-html5.md#13-部分領域をキャンバスに表示する "INTERNAL")で説明した通りです。

#### HTML要素とイベント

トラックバーは`<input type="range">`から生成します（11行目）。この要素にはトラックバーの最小値（`min`）、最大値（`max`）、現在値（`value`）を指定する属性が用意されていますが、スクリプトから設定するのでここでは未指定です。

```html
11    <input type="range" id="rangeTag"/>
```

これら値の設定は、リソースの読み込み完了後（49行目）に呼び出される`imageLoaded()`関数（32～47行目）から行います。

```javascript
 32    function imageLoaded() {
 ︙
 49    window.addEventListener('load', imageLoaded);
```  

最小値は10を規定値とし、最大値には`HTMLImageElement.naturalWidth`を使います。現在値は`<img>`属性で指定された320（15行目）を踏襲します。

```javascript
 35      rangeElem.min = 10;
 36      rangeElem.max = imgElem.naturalWidth;
 37      rangeElem.value = imgElem.width;
```

`<input type="range">`にはスライダーを動かしたときの値を指定する増加量（`step`）属性もありますが、ここでは用いていないのでデフォルトの1です。0.1のような小数点数や2のようなとびとびの値も指定できます。

#### トラックバーの値

トラックバーイベント処理の関数は`sizeChanged()`（42～47行目）です。ここで重要なのは39行目です。

<!-- canvas.height 代入時に自動的に int に変換されるので、Math.floor() は実は不要である。-->
```javascript
 42      canvasElem.width = Number(rangeElem.value);
```

`HTMLInputElement.value`プロパティのデータ型は文字列（`string`）なので、`Number()`から数値（`number`）に変換しなければなりません。設定次第で小数点数（の文字列表記）のこともあるので、`parseInt()`は避けたほうがよいでしょう。



### 2.7 マウス操作で部分領域を切り取る

#### 目的

マウス操作で画像内の部分矩形領域を選択し、その部分をキャンバスにコピーして貼り付けます。マウスボタンを押下したら、そこが矩形の頂点です。押下しながらそのままドラッグし、マウスボタンを離したところが対角の頂点で、その時点で矩形が確定します。マウスドラッグ中はどこが選択されているかわかるよう、枠線をアニメーションで示します。

技術的には`mousedown`、`mousemove`、`mouseup`の3つのイベントを組み合わせ、その時点がどの操作状態なのかを判定する方法を説明します。また、選択した領域と切り出す領域の座標系が異なるので、その対処方法も示します。

画像処理では、部分領域だけを対象とすることがよくあります。たとえば、道路の写真から標識だけを抜き取りたいとか、顔だけぼかしたいとかです。そこで、領域選択の機能はクラスとして別ファイルにすることで、他所から再利用できるようにします。

実行例を次の画面に示します。

<img src="Images/Ch02/ui-regionselect-1.png">

左が画像を表示する`<img>`で、選択中の矩形は白い破線で示されます。右の`<canvas>`にはコピーした部分領域が貼り付けられます。左と右で寸法は一致しています。ここでは`<img>`はオリジナルの1/4に縮小表示されているので、`<canvas>`も同じように1/4に縮小されているということです。

コンソールには領域が数値で示されます。Selectedとある4つの数値の最初の2つ（114, 62）が左上の頂点で、残り2つ（149, 110）が矩形のサイズです。どちらも`<img>`上のが座標系です。

Source atの値は、Selectedの値を縮小表示されるまえの、もともとの画像の座標系で表現したものです。オリジナルの画像は表示されたものより大きいので（ここでは1290×960）、頂点座標もサイズもそれに比例して大きくなっています。

#### コード（クラス）

領域選択機能は、クラス化して別ファイル`libs/regionselect.js`に収容しました。次に示します。

```javascript
[File] regionselect.js
  4  class RegionSelect {
 ︙
  9    constructor(imageTag) {
 10      this.imgElem = document.getElementById(imageTag);
 11      let divElem = this.imgElem.parentElement;
 12      divElem.style.position = 'relative';
 13
 14      let canvasElem = document.createElement('canvas');
 15      divElem.appendChild(canvasElem);
 16      this.ctx = canvasElem.getContext('2d');
 17
 18      canvasElem.width = this.imgElem.offsetWidth;
 19      canvasElem.height = this.imgElem.offsetHeight;
 20      canvasElem.style.position = 'absolute';
 21      canvasElem.style.top = '0px';
 22      canvasElem.style.left = '0px';
 23      canvasElem.style.backgroundColor = 'transparent';
 24      canvasElem.style.zIndex = 2;
 25
 26      this.x = 0;
 27      this.y = 0;
 28      this.width = 0;
 29      this.height = 0;
 30      this.mouseState = undefined;
 31
 32      canvasElem.addEventListener('mousedown', () => this.mouseDown(event));
 33      canvasElem.addEventListener('mousemove', () => this.mouseMove(event));
 34      canvasElem.addEventListener('mouseup', () => this.mouseUp(event));
 35    }
 36
 37    drawRectangle() {
 38      this.ctx.reset();
 39      this.ctx.setLineDash([5]);
 40      this.ctx.strokeStyle = 'white';
 41      this.ctx.strokeRect(this.x, this.y, this.width, this.height);
 42    }
 43
 44    mouseDown(evt) {
 45      if (this.mouseState === undefined) {
 46         this.mouseState = 'down';
 47         this.x = evt.offsetX;
 48         this.y = evt.offsetY;
 49         this.width = this.height = 0;
 50       }
 51    }
 52
 53    mouseMove(evt) {
 54     if (this.mouseState === 'down') {
 55        this.width = evt.offsetX - this.x;
 56        this.height = evt.offsetY - this.y;
 57        this.drawRectangle();
 58     }
 59    }
 60
 61    mouseUp(evt) {
 62     if (this.mouseState === 'down') {
 63        this.mouseState = undefined;
 64        let rect = [this.x, this.y, this.width, this.height];
 65        let regionSelect = new CustomEvent('regionselect', {detail: rect});
 66        this.imgElem.dispatchEvent(regionSelect);
 67     }
 68    }
 69
 70  } // end of class
```

#### 透明なキャンバスを重畳する

クラスの基本構成は[2.4節](#24-日本語文字を画像に重畳する "INTERNAL")と同じで、ターゲットの`<img>`オブジェクトの上に透明で同サイズの`HTMLCanvasElement`を貼り付け、そこに選択領域の枠線を描きます。したがって、`<img>`は`<div>`の内部に収容されていなければなりません。

コンストラクタは引数に`<img>`の`id`属性を受け取ると、最初に親要素の`<div>`を取得し、配置設定をします（10～12行目）。

```javascript
 10      this.imgElem = document.getElementById(imageTag);
 11      let divElem = this.imgElem.parentElement;
 12      divElem.style.position = 'relative';
```

続いて、`<div>`の下に`<canvas>`を生成します（14～16行目）。

```javascript
 14      let canvasElem = document.createElement('canvas');
 15      divElem.appendChild(canvasElem);
 16      this.ctx = canvasElem.getContext('2d');
```

あとは、`<canvas>`のサイズやCSSスタイルを設定するだけです（18～24行目）。[2.4節](#24-日本語文字を画像に重畳する "INTERNAL")では指定しませんでしたが、ここではレイヤの位置を指定する`zIndex`も加えています（24行目）。値はレイヤ上の絶対的な順番ではなく、相対的なものです。値が小さいほうが下、大きいほうが上です。

```javascript
 24      canvasElem.style.zIndex = 2;
```

#### HTML要素とイベント

処理対象のイベントは次の表に示す3点です。

イベント | 状態 | 操作
---|---|---
`mousedown` | 選択開始 | 頂点座標(x, y)を得る。過去の選択があれば、その結果を廃棄する。
`mousemove` | 選択中 | 一時的な対角座標(x', y')を得て、枠線を描く。
`mouseup` | 選択終了 | 対角座標を決定し、矩形情報(x, y, width, height)を報告する。その後、ふたたび選択開始状態に戻る。

これらを、`<img>`に登録しているのが、32～34行目です。

```javascript
 32      canvasElem.addEventListener('mousedown', () => this.mouseDown(event));
 33      canvasElem.addEventListener('mousemove', () => this.mouseMove(event));
 34      canvasElem.addEventListener('mouseup', () => this.mouseUp(event));
```

イベントリスナー関数は、あえてアロー関数で書いています。これを`this.mouseDown`のように書くと、その関数の`this`がコンストラクタの`this`をオーバーライトしてしまうからです。

`mousemove`イベントを処理する`mouseMove()`関数（53～59行目）の最初の部分から考えます。

```javascript
 53    mouseMove(evt) {
 54     if (this.mouseState === 'down') {
```

54行目の`this.mouseState`はこの`RegionSelect`オブジェクトの`mouseState`（30行目）を参照しているつもりです。しかし、アロー関数を使わないと、その`this`は呼び出しもとのオブジェクト、つまり`HTMLImageElement`を指し示します。そこには`mouseState`なるプロパティは存在しないので`undefined`です。つまり、この`if`文はどんなときでも成立しません。

アロー関数は`this`を使いません。したがって、その内部の`this`は意図通りに`RegionSelect`オブジェクトを指す`this`になります。

#### RegionSelectの関数

`RegionSelect`クラスには4つの関数が用意してあります。次の表にまとめて示します。

関数 | 対応イベント | 行番号 | 処理
---|---|---|---
`drawRectangle()` | なし | 37～42 | キャンバスに矩形を描く。`mouseDown()`からのみ呼び出す。
`mouseDown()` | `mousedown` | 44～51 | 矩形選択開始。(x, y)の位置を定め、キャンバスをリセットする。
`mouseMove()` | `mousemove` | 53～59 | 矩形選択中。操作中、(x, y)は固定のまま、一時的な対角位置(x', y')から(width, height)をその都度セットしていく。マウス操作にあわせて`drawRectangle()`で矩形を描く。
`mouseUp()` | `mouseup` | 61～68 | 矩形選択終了。(x, y, width, height)のデータをカスタムイベント`regionselect`からリスナーに届ける。

マウス操作関係の3つの関数は、後述の状態管理にしたがって矩形領域の位置とサイズを変更するくらいしかしていません。実際の描画は`drawRectangle()`がやっていますが、`strokeRect()`で塗りつぶしなし矩形を描いているくらいです。

#### 状態管理

`RegionSelect`オブジェクトには、マウスボタンが押されているか離されているかの2つの状態があります。この状態を管理しているのが30行目の`this.mouseState`です。

最初は`undefined`ですが、`mousedown`を契機に`down`に移行します（44行目からの`mouseDown()`関数の先頭）。

```javascript
 30      this.mouseState = undefined;       // コンストラクタ（初期状態）
 ︙
 44    mouseDown(evt) {
 45      if (this.mouseState === undefined) {
 46         this.mouseState = 'down';
```

downの状態のまま`mousemove`が発生すると、枠線を描画します（53行目からの`mouseMove()`関数の先頭）。状態は変化せず、downのままです。

```javascript
 53    mouseMove(evt) {
 54     if (this.mouseState === 'down') {
```

マウスが押されたまま（状態がdownのまま）でなければ枠線を描画しないようにしないと、画像をマウスが横切っただけで領域の輪郭線が引かれてしまいます。枠線をキャンバスに描画するのが`drawRectangle()`関数です（37～42行目）。この描画関数は毎回描画コンテクストの`reset()`を呼び出すので、枠線が多重になることはありません。

```javascript
 37    drawRectangle() {
 38      this.ctx.reset();
```

down状態のまま`mouseUp`が発生すると、枠線確定です（61行目からの`mouseUp()`関数の先頭）。状態は`undefined`に戻ります。

```javascript
 61    mouseUp(evt) {
 62     if (this.mouseState === 'down') {
 63        this.mouseState = undefined;
```

枠線が確定したら、その旨を`<img>`オブジェクトにカスタムイベントで通知します（65～66行目）。

```javascript
 64        let rect = [this.x, this.y, this.width, this.height];
 65        let regionSelect = new CustomEvent('regionselect', {detail: rect});
 66        this.imgElem.dispatchEvent(regionSelect);
```

カスタムイベントにはどのような名前を付けてもかまいません。ここでは`regionselect`という名にしました（65行目）。カスタムイベント作成の`CustomEvent`コンストラクタには、オプションで相手に伝えるデータを第2引数から同梱できます。データはオブジェクト形式で、`detail`というプロパティを用います。ここでは、選択された矩形領域を収容した4要素の配列（64行目）を指定しています。

`RegionSelect`オブジェクトの状態遷移を次の図に示します。

<!-- 884x260 ODG ファイルに原画あり -->
<img src="Images/Ch02/ui-regionselect-state.png" width="500">

なお、マウスが押下されたまま画像（キャンバス）の外に出ると、対策はしていないので、やや怪しい挙動を示します。別条はありません。気になるなら他のマウスイベントの利用を考えてください。

#### コード（メイン部分）

メイン部分のコード`ui-regionselect.html`を次に示します。

```html
[File] ui-regionselect.html
  1  <!DOCTYPE html>
  2  <html lang="ja-JP">
  3  <head>
  4    <meta charset="UTF-8"></head>
  5    <link rel=stylesheet type="text/css" href="style.css">
  6    <script src="libs/regionselect.js"></script>
  7  <body>
  8
  9  <h1>マウス操作で部分領域を切り取る</h1>
 10
 11  <div id="divTag">
 12    <img id="imageTag" width="320" src="samples/avon-river.jpg"/>
 13    <canvas id="canvasTag" class="placeholder"></canvas>
 14  </div>
 15
 16  <script>
 17    let imgElem = document.getElementById('imageTag');
 18    let canvasElem = document.getElementById('canvasTag');
 19    let ctx = canvasElem.getContext('2d');
 20
 21    function copyRegion(evt) {
 22      let [x, y, width, height] = evt.detail;
 23      let scale = imgElem.naturalWidth / imgElem.width;
 24      let [x_img, y_img, w_img, h_img] = evt.detail.map(
 25        elem => Math.floor(elem*scale));
 26      canvasElem.width = Math.abs(width);
 27      canvasElem.height = Math.abs(height);
 28      ctx.drawImage(imgElem, x_img, y_img, w_img, h_img,
 29        0, 0, canvasElem.width, canvasElem.height);
 30      console.log(`Selected: ${evt.detail}
 31        Source at (${x_img}, ${y_img}) ${w_img}x${h_img}`);
 32    }
 33
 34    function imageLoaded() {
 35      let rs = new RegionSelect('imageTag');
 36      imgElem.addEventListener('regionselect', copyRegion);
 37    }
 38
 39    window.addEventListener('load', imageLoaded);
 40  </script>
 41
 42  </body>
 43  </html>
```

面倒な操作は`RegionSelect`で実装済みなので、呼び出し側はシンプルです。クラスの利用にかかわる重要な点は次の通り。

- `<img>`は`id`属性を持った`<div>`でくくります（11～14行目）。
- `RegionSelect`は、初期化時点で1度だけインスタンス化します（35行目）。
- `<img>`に領域選択完了イベントの`regionselect`を登録します（36行目）。
- 右下を起点に左上で領域を選択すると、横幅とか高さが負の値になります（22行目の`width`と`height`）。これらをそのままキャンバスサイズに指定すると、見えない負のサイズのキャンバスになっていまいます。そこで、絶対値を取ります（26～27行目）。

#### 部分領域のコピー

`<img>`（正確にはその上の透明な`<canvas>`）上で選択した領域の座標系は、縮小表示された画像のものです。たとえば、オリジナルの画像が1280x960で、それが1/4の320x240で表示されているとしたら、xの値は0～320、yの値は0～240の範囲です。しかし、部分領域をコピーするときの`CanvasRenderingContext2D: drawImage()`の第2～5引数は画像のもともとのサイズ（`HTMLImageElement.naturalWidth, naturalHeight`）を参照します。

そのため、カスタムイベントの`detail`プロパティから(x, y, width, height)を取得したら、それらを適切にスケーリングしなければなりません。それをやっているのが22～25行目です。

```javascript
 22      let [x, y, width, height] = evt.detail;
 23      let scale = imgElem.naturalWidth / imgElem.width;
 24      let [x_img, y_img, w_img, h_img] = evt.detail.map(
 25        elem => Math.floor(elem*scale));
```

22行目は、`<img>`上で拡大縮小された画像での座標系です（分割代入しています）。23行目はそれとオリジナルの画像との倍率を計算しています。そして、24行目で22行目の値をすべてその倍率で拡大縮小しています。
