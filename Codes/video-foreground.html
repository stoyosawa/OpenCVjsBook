<!DOCTYPE html>
<html lang="ja-JP">
<head>
  <meta charset="UTF-8">
  <link rel=stylesheet type="text/css" href="style.css">
  <script async src="libs/opencv.js" type="text/javascript"></script>
</head>
<body>

<h1>動いているものだけを抜き出す</h1>

<div>
  <video id="videoTag" width="360" autoplay muted src="samples/motorway.mp4"></video>
  <canvas id="canvasTag" class="placeholder"></canvas>
</div>
<div>
  <canvas id="canvasTag1" class="placeholder"></canvas>
  <canvas id="canvasTag2" class="placeholder"></canvas>
  <canvas id="canvasTag3" class="placeholder"></canvas>
</div>

<script>
  let videoElem = document.getElementById('videoTag');
  let srcOrig, src, srcGray, bgGray, fgGray, mask, dst;
  let frameCallbackHandle;
  let readyFlag = 0;

  function showImage(canvasID, src, half=false) {
    let mat = new cv.Mat();
    if (src.depth === cv.CV_32F)
      src.convertTo(mat, cv.CV_8UC3, 255);
    else
      mat = src.clone();
    if (half)
      cv.resize(mat, mat, new cv.Size(), 0.5, 0.5);
    cv.imshow(canvasID, mat);
    mat.delete();
  }

  function perFrame() {
    if (readyFlag !== 3)
      return;

    // 元フレームにはカラー版（src）とグレー版（srcGray）を用意する。どちらも cv.CV_32FC3
    let cap = new cv.VideoCapture(videoElem);
    cap.read(srcOrig);
    cv.cvtColor(srcOrig, src, cv.COLOR_RGBA2RGB);
    src.convertTo(src, cv.CV_32FC3, 1/255)
    cv.cvtColor(src, srcGray, cv.COLOR_RGB2GRAY);

    // 背景画像と加算していくころで、前景抜きの画像を生成する
    cv.addWeighted(srcGray, 0.01, bgGray, 0.99, 0.0, bgGray);         // マニュアルには multichannel でもチャネル単位にやると書いてあるが、32FC4 のままだとエラーになる。
    showImage('canvasTag1', bgGray, true);

    // 差分を取ることで前景画像を生成する
    cv.absdiff(srcGray, bgGray, fgGray);
    showImage('canvasTag2', fgGray, true);

    // 前景を 8UC1 に戻すことで、マスク画像にする
    fgGray.convertTo(mask, cv.CV_8UC1, 255);
    cv.threshold(mask, mask, 0, 255, cv.THRESH_BINARY | cv.THRESH_OTSU);
    showImage('canvasTag3', mask, true);

    // 現在のフレームの CV_8UC3版に前景マスクをかける
    dst.data32F.fill(0.8);
    src.copyTo(dst, mask);
    showImage('canvasTag', dst);

    frameCallbackHandle = videoElem.requestVideoFrameCallback(perFrame);
  }


  function stop() {
    [srcOrig, src, srcGray, bgGray, fgGray, mask, dst].forEach(
      m => m.delete());
    videoElem.cancelVideoFrameCallback(frameCallbackHandle);
    videoElem.removeEventListener('pause', stop);
    videoElem.removeEventListener('ended', stop);
    readyFlag = 0;
  }

  function init() {
    if (readyFlag != 3)
      return;

    srcOrig = new cv.Mat(videoElem.height, videoElem.width, cv.CV_8UC4);
    src = new cv.Mat();
    srcGray = new cv.Mat();
    bgGray = new cv.Mat(videoElem.height, videoElem.width, cv.CV_32FC1,
      new cv.Scalar(0.5));
    fgGray = new cv.Mat();
    mask = new cv.Mat();
    dst = new cv.Mat(videoElem.height, videoElem.width, cv.CV_8UC3);

    perFrame();    
  }

  function videoReady() {
    readyFlag |= 2;
    videoElem.width = videoElem.offsetWidth;
    videoElem.height = videoElem.offsetHeight;
    init();
  }

  function opencvReady() {
    readyFlag |= 1;
    init();
  }

  videoElem.addEventListener('loadeddata', videoReady);
  videoElem.addEventListener('pause', stop);
  videoElem.addEventListener('ended', stop);
  var Module = {
    onRuntimeInitialized: opencvReady
  }
</script>

</body>
</html>
